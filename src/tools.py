"""
Tools module for the MCP server.
Provides ChromaDB integration and utility tools.
Generated by Copilot
"""

import logging
from typing import Dict, Any, List, Optional
import chromadb
from chromadb.config import Settings
from chromadb.types import Metadata

# Import embedding modules
try:
    from .embedding import EmbeddingManager
except ImportError:
    # Fallback for standalone running
    import sys
    import os
    sys.path.append(os.path.dirname(__file__))
    from embedding import EmbeddingManager

logger = logging.getLogger(__name__)


class MCPTools:
    """
    Tools handler for MCP server operations.
    Provides ChromaDB integration and utility functions.
    """

    def __init__(self):
        """Initialize the tools handler."""
        self.chroma_client = None
        self.embedding_manager = EmbeddingManager()
        self._initialize_chroma()
        self._initialize_embeddings()

    def _initialize_chroma(self):
        """Initialize ChromaDB client."""
        try:
            # Initialize ChromaDB with persistent storage
            self.chroma_client = chromadb.PersistentClient(path="./chroma_db")
            logger.info("ChromaDB client initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize ChromaDB: {e}")
            self.chroma_client = None

    def _initialize_embeddings(self):
        """Initialize embedding manager with best available model."""
        try:
            logger.info("Initializing embedding manager...")
            success = self.embedding_manager.load_best_available_model()
            if success:
                model_info = self.embedding_manager.get_model_info()
                logger.info(f"Embedding manager initialized with: {model_info['name']}")
            else:
                logger.warning("Embedding manager initialized with ChromaDB default")
        except Exception as e:
            logger.error(f"Failed to initialize embeddings: {e}")
            # Continue with ChromaDB default

    def get_tools_list(self) -> List[Dict[str, Any]]:
        """
        Get list of available tools.

        Returns:
            List of tool definitions
        """
        tools = [
            {
                "name": "create_collection",
                "description": "Create a new ChromaDB collection",
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "name": {
                            "type": "string",
                            "description": "Name of the collection to create",
                        },
                        "metadata": {
                            "type": "object",
                            "description": "Optional metadata for the collection",
                        },
                    },
                    "required": ["name"],
                },
            },
            {
                "name": "list_collections",
                "description": "List all ChromaDB collections",
                "inputSchema": {"type": "object", "properties": {}},
            },
            {
                "name": "add_documents",
                "description": "Add documents to a ChromaDB collection",
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "collection_name": {
                            "type": "string",
                            "description": "Name of the collection",
                        },
                        "documents": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "List of documents to add",
                        },
                        "metadatas": {
                            "type": "array",
                            "items": {"type": "object"},
                            "description": "Optional metadata for each document",
                        },
                        "ids": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "Optional IDs for each document",
                        },
                    },
                    "required": ["collection_name", "documents"],
                },
            },
            {
                "name": "query_collection",
                "description": "Query a ChromaDB collection",
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "collection_name": {
                            "type": "string",
                            "description": "Name of the collection to query",
                        },
                        "query_texts": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "List of query texts",
                        },
                        "n_results": {
                            "type": "integer",
                            "description": "Number of results to return (default: 10)",
                        },
                        "where": {
                            "type": "object",
                            "description": "Optional metadata filter",
                        },
                    },
                    "required": ["collection_name", "query_texts"],
                },
            },
            {
                "name": "delete_collection",
                "description": "Delete a ChromaDB collection",
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "name": {
                            "type": "string",
                            "description": "Name of the collection to delete",
                        }
                    },
                    "required": ["name"],
                },
            },            {
                "name": "echo",
                "description": "Echo back the input (useful for testing)",
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "message": {
                            "type": "string",
                            "description": "Message to echo back",
                        }
                    },
                    "required": ["message"],
                },
            },
            {
                "name": "configure_embedding_model",
                "description": "Configure the embedding model to use",
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "model_name": {
                            "type": "string",
                            "description": "Name of the embedding model (e.g., mixedbread-ai/mxbai-embed-large-v1)",
                        },
                        "force_reload": {
                            "type": "boolean",
                            "description": "Force reload if model is already loaded",
                        },
                    },
                    "required": ["model_name"],
                },
            },
            {
                "name": "get_embedding_model_info",
                "description": "Get information about current embedding model",
                "inputSchema": {"type": "object", "properties": {}},
            },
            {
                "name": "chunk_text_intelligent",
                "description": "Intelligently chunk text for better embedding (Vietnamese optimized)",
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "text": {
                            "type": "string",
                            "description": "Text to chunk",
                        },
                        "chunk_size": {
                            "type": "integer",
                            "description": "Maximum chunk size (default: 400)",
                        },
                        "overlap": {
                            "type": "integer",
                            "description": "Overlap between chunks (default: 50)",
                        },
                    },
                    "required": ["text"],
                },
            },
        ]

        return tools

    def call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Any:
        """
        Call a specific tool with given arguments.

        Args:
            tool_name: Name of the tool to call
            arguments: Arguments for the tool

        Returns:
            Tool execution result

        Raises:
            ValueError: If tool is not found or ChromaDB is not available
            Exception: If tool execution fails
        """
        if tool_name == "echo":
            return self._echo(arguments)
        elif tool_name == "create_collection":
            return self._create_collection(arguments)
        elif tool_name == "list_collections":
            return self._list_collections(arguments)
        elif tool_name == "add_documents":
            return self._add_documents(arguments)
        elif tool_name == "query_collection":
            return self._query_collection(arguments)
        elif tool_name == "delete_collection":
            return self._delete_collection(arguments)
        elif tool_name == "configure_embedding_model":
            return self._configure_embedding_model(arguments)
        elif tool_name == "get_embedding_model_info":
            return self._get_embedding_model_info(arguments)
        elif tool_name == "chunk_text_intelligent":
            return self._chunk_text_intelligent(arguments)
        else:
            raise ValueError(f"Unknown tool: {tool_name}")

    def _echo(self, arguments: Dict[str, Any]) -> str:
        """Echo tool implementation."""
        message = arguments.get("message", "")
        return f"Echo: {message}"

    def _create_collection(self, arguments: Dict[str, Any]) -> str:
        """Create a new ChromaDB collection."""
        if not self.chroma_client:
            raise Exception("ChromaDB client not available")

        name = arguments["name"]
        metadata = arguments.get("metadata", {})

        try:
            collection = self.chroma_client.create_collection(
                name=name, metadata=metadata
            )
            return f"Collection '{name}' created successfully"
        except Exception as e:
            raise Exception(f"Failed to create collection: {str(e)}")

    def _list_collections(self, arguments: Dict[str, Any]) -> List[str]:
        """List all ChromaDB collections."""
        if not self.chroma_client:
            raise Exception("ChromaDB client not available")

        try:
            collections = self.chroma_client.list_collections()
            return [col.name for col in collections]
        except Exception as e:
            raise Exception(f"Failed to list collections: {str(e)}")

    def _add_documents(self, arguments: Dict[str, Any]) -> str:
        """Add documents to a ChromaDB collection with custom embeddings."""
        if not self.chroma_client:
            raise Exception("ChromaDB client not available")

        collection_name = arguments["collection_name"]
        documents = arguments["documents"]
        metadatas = arguments.get("metadatas")
        ids = arguments.get("ids")

        try:
            collection = self.chroma_client.get_collection(collection_name)

            # Generate IDs if not provided
            if ids is None:
                ids = [f"doc_{i}" for i in range(len(documents))]            # Clean and prepare metadata for ChromaDB
            cleaned_metadatas: Optional[List[Metadata]] = None
            if metadatas:
                cleaned_metadatas = []
                for meta in metadatas:
                    clean_meta: Metadata = {}
                    for k, v in meta.items():
                        if isinstance(v, (str, int, float, bool)) or v is None:
                            clean_meta[k] = v
                        else:
                            clean_meta[k] = str(v)
                    cleaned_metadatas.append(clean_meta)            # 🔥 Use custom embeddings if available
            embeddings = self.embedding_manager.encode_documents(documents)
            if embeddings:
                # Type cast for ChromaDB compatibility
                embeddings_list = embeddings  # Already converted to list in encode_documents
                collection.add(
                    documents=documents, 
                    metadatas=cleaned_metadatas, 
                    ids=ids,
                    embeddings=embeddings_list  # type: ignore
                )
                model_info = self.embedding_manager.get_model_info()
                return f"Added {len(documents)} documents to collection '{collection_name}' using {model_info['name']} embeddings"
            else:
                # Fallback to ChromaDB default
                collection.add(documents=documents, metadatas=cleaned_metadatas, ids=ids)
                return f"Added {len(documents)} documents to collection '{collection_name}' using ChromaDB default embeddings"

        except Exception as e:
            raise Exception(f"Failed to add documents: {str(e)}")

    def _query_collection(self, arguments: Dict[str, Any]) -> Any:
        """Query a ChromaDB collection with custom query embeddings."""
        if not self.chroma_client:
            raise Exception("ChromaDB client not available")

        collection_name = arguments["collection_name"]
        query_texts = arguments["query_texts"]
        n_results = arguments.get("n_results", 10)
        where = arguments.get("where")

        try:
            collection = self.chroma_client.get_collection(collection_name)

            # 🔥 Use custom query embeddings if available
            if len(query_texts) > 0:
                query_embedding = self.embedding_manager.encode_query(query_texts[0])
                if query_embedding:
                    results = collection.query(
                        query_embeddings=[query_embedding], 
                        n_results=n_results, 
                        where=where
                    )
                else:
                    # Fallback to text-based query
                    results = collection.query(
                        query_texts=query_texts, n_results=n_results, where=where
                    )
            else:
                raise Exception("No query texts provided")

            return results
        except Exception as e:
            raise Exception(f"Failed to query collection: {str(e)}")

    def _delete_collection(self, arguments: Dict[str, Any]) -> str:
        """Delete a ChromaDB collection."""
        if not self.chroma_client:
            raise Exception("ChromaDB client not available")

        name = arguments["name"]

        try:
            self.chroma_client.delete_collection(name)
            return f"Collection '{name}' deleted successfully"
        except Exception as e:
            raise Exception(f"Failed to delete collection: {str(e)}")

    def _configure_embedding_model(self, arguments: Dict[str, Any]) -> str:
        """Configure the embedding model."""
        model_name = arguments["model_name"]
        force_reload = arguments.get("force_reload", False)
        
        try:
            success = self.embedding_manager.load_model(model_name, force_reload)
            if success:
                model_info = self.embedding_manager.get_model_info()
                return f"Successfully configured embedding model: {model_info['name']} (dim: {model_info['embedding_dim']})"
            else:
                return f"Failed to load model '{model_name}'. Using ChromaDB default."
        except Exception as e:
            raise Exception(f"Failed to configure embedding model: {str(e)}")

    def _get_embedding_model_info(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """Get information about current embedding model."""
        try:
            return self.embedding_manager.get_model_info()
        except Exception as e:
            raise Exception(f"Failed to get embedding model info: {str(e)}")

    def _chunk_text_intelligent(self, arguments: Dict[str, Any]) -> List[str]:
        """Intelligently chunk text for better embeddings."""
        text = arguments["text"]
        chunk_size = arguments.get("chunk_size", 400)
        overlap = arguments.get("overlap", 50)
        
        try:
            chunks = self.embedding_manager.intelligent_chunk_text(text, chunk_size, overlap)
            return chunks
        except Exception as e:
            raise Exception(f"Failed to chunk text: {str(e)}")
