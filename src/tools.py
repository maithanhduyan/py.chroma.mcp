"""
MCP Tools with FastMCP Integration
Provides ChromaDB integration and utility tools using MCP protocol
Generated by Copilot
"""

"""
list of tools:
- echo()
- list_collections() 
- create_collection()
- delete_collection()
- add_documents()
- query_collection()
- get_embedding_model_info()
- configure_embedding_model()
- chunk_text_intelligent()
"""

import logging
from typing import Dict, Any, List, Optional
import chromadb
from chromadb.config import Settings
from chromadb.types import Metadata
from mcp.server.fastmcp import FastMCP

# Import embedding modules
import sys
import os

# Ensure proper imports work by adding src to path if needed
current_dir = os.path.dirname(__file__)
src_dir = (
    os.path.dirname(current_dir)
    if os.path.basename(current_dir) == "src"
    else current_dir
)
if src_dir not in sys.path:
    sys.path.insert(0, src_dir)

# Now do the imports - they should work whether run as module or standalone
try:
    from .embedding import EmbeddingManager
    from .embedding.chunker import chunk_text_intelligent as _chunk_text_intelligent
    from .utils.metrics import (
        track_execution_time,
        measure_memory_usage,
        MetricsCollector,
    )
except ImportError:
    # If relative imports fail, try absolute imports
    from embedding import EmbeddingManager
    from embedding.chunker import chunk_text_intelligent as _chunk_text_intelligent
    from utils.metrics import (
        track_execution_time,
        measure_memory_usage,
        MetricsCollector,
    )

HAS_METRICS = True

logger = logging.getLogger(__name__)

# Initialize FastMCP instance
mcp = FastMCP("chroma-embedding-tools")

# Global instances
_chroma_client = None
_embedding_manager = None


def get_chroma_client():
    """Get or create the global Chroma client instance."""
    global _chroma_client
    if _chroma_client is None:
        _chroma_client = chromadb.PersistentClient(path="./chroma_db")
    return _chroma_client


def get_embedding_manager():
    """Get or create the global embedding manager instance."""
    global _embedding_manager
    if _embedding_manager is None:
        _embedding_manager = EmbeddingManager()
        # Load default small model asynchronously when needed
        logger.debug("ðŸ§  EmbeddingManager initialized")
    return _embedding_manager


##### Core ChromaDB Tools with Embedding Integration #####


@mcp.tool()
async def echo(message: str) -> str:
    """Echo back the input message (useful for testing)."""
    return f"Echo: {message}"


@mcp.tool()
async def list_collections() -> List[str]:
    """List all collection names in the ChromaDB."""
    client = get_chroma_client()
    try:
        collections = client.list_collections()
        if not collections:
            return []
        return [coll.name for coll in collections]
    except Exception as e:
        logger.error(f"Failed to list collections: {e}")
        raise Exception(f"Failed to list collections: {str(e)}")


@mcp.tool()
async def create_collection(
    name: str, metadata: Optional[Dict[str, Any]] = None
) -> str:
    """Create a new ChromaDB collection."""
    client = get_chroma_client()
    try:
        # Use None instead of empty dict to avoid validation error
        collection = client.create_collection(name=name, metadata=metadata)
        return f"Collection '{name}' created successfully"
    except Exception as e:
        logger.error(f"Failed to create collection '{name}': {e}")
        raise Exception(f"Failed to create collection '{name}': {str(e)}")


@mcp.tool()
async def delete_collection(name: str) -> str:
    """Delete a ChromaDB collection."""
    client = get_chroma_client()
    try:
        client.delete_collection(name)
        return f"Collection '{name}' deleted successfully"
    except Exception as e:
        logger.error(f"Failed to delete collection '{name}': {e}")
        raise Exception(f"Failed to delete collection '{name}': {str(e)}")


@mcp.tool()
async def add_documents(
    collection_name: str,
    documents: List[str],
    ids: Optional[List[str]] = None,
    metadatas: Optional[List[Dict[str, Any]]] = None,
) -> str:
    """Add documents to a ChromaDB collection with custom embeddings."""
    if not documents:
        raise ValueError("Documents list cannot be empty")

    # Clean and validate documents
    clean_documents = []
    for i, doc in enumerate(documents):
        if not isinstance(doc, str):
            logger.warning(f"Document {i} converted from {type(doc)} to string")
            doc = str(doc)
        doc = doc.strip()
        if doc:  # Only add non-empty documents
            clean_documents.append(doc)

    if not clean_documents:
        raise ValueError("No valid documents after cleaning")

    # Generate IDs if not provided
    if ids is None:
        ids = [f"doc_{i}" for i in range(len(clean_documents))]

    client = get_chroma_client()
    embedding_manager = get_embedding_manager()

    try:
        collection = client.get_or_create_collection(collection_name)

        # Try to use custom embeddings if available
        embeddings = None
        if embedding_manager.current_model is not None:
            try:
                embeddings = embedding_manager.encode_documents(clean_documents)
                model_info = embedding_manager.get_model_info()
                model_name = model_info.get("name", "unknown")
                logger.info(f"Using custom embeddings: {model_name}")
            except Exception as e:
                logger.warning(
                    f"Custom embedding failed, falling back to ChromaDB default: {e}"
                )

        # Add documents with or without custom embeddings
        if embeddings is not None:
            collection.add(
                documents=clean_documents,
                embeddings=embeddings,  # type: ignore
                ids=ids[: len(clean_documents)],
                metadatas=metadatas[: len(clean_documents)] if metadatas else None,  # type: ignore
            )
            model_info = embedding_manager.get_model_info()
            model_name = model_info.get("name", "unknown")
            return f"Added {len(clean_documents)} documents to '{collection_name}' using {model_name} embeddings"
        else:
            collection.add(
                documents=clean_documents,
                ids=ids[: len(clean_documents)],
                metadatas=metadatas[: len(clean_documents)] if metadatas else None,  # type: ignore
            )
            return f"Added {len(clean_documents)} documents to '{collection_name}' using ChromaDB default embeddings"

    except Exception as e:
        logger.error(f"Failed to add documents to '{collection_name}': {e}")
        raise Exception(f"Failed to add documents: {str(e)}")


@mcp.tool()
async def query_collection(
    collection_name: str,
    query_texts: List[str],
    n_results: int = 10,
    where: Optional[Dict[str, Any]] = None,
) -> Any:
    """Query a ChromaDB collection with semantic search."""
    if not query_texts:
        raise ValueError("Query texts cannot be empty")

    client = get_chroma_client()
    embedding_manager = get_embedding_manager()

    try:
        collection = client.get_collection(collection_name)

        # Try to use custom query embeddings if available
        query_embeddings = None
        if embedding_manager.current_model is not None and len(query_texts) > 0:
            try:
                # Convert to list for encoding
                embeddings_list = []
                for query_text in query_texts:
                    embedding = embedding_manager.encode_query(query_text)
                    if embedding:
                        embeddings_list.append(embedding)

                if embeddings_list:
                    query_embeddings = embeddings_list
                    model_info = embedding_manager.get_model_info()
                    model_name = model_info.get("name", "unknown")
                    logger.info(f"Using custom query embeddings: {model_name}")
            except Exception as e:
                logger.warning(
                    f"Custom query embedding failed, falling back to ChromaDB default: {e}"
                )

        # Perform query
        if query_embeddings:
            results = collection.query(
                query_embeddings=query_embeddings,  # type: ignore
                n_results=n_results,
                where=where,
            )
        else:
            results = collection.query(
                query_texts=query_texts,
                n_results=n_results,
                where=where,
            )

        # Convert ChromaDB QueryResult to dict for JSON serialization
        return dict(results)  # type: ignore

    except Exception as e:
        logger.error(f"Failed to query collection '{collection_name}': {e}")
        raise Exception(f"Failed to query collection: {str(e)}")


##### Embedding Management Tools #####


@mcp.tool()
async def get_embedding_model_info() -> Dict[str, Any]:
    """Get information about current embedding model."""
    embedding_manager = get_embedding_manager()
    try:
        model_info = embedding_manager.get_model_info()
        if model_info:
            # Return the dictionary as-is since get_model_info already returns a properly formatted dict
            return model_info
        else:
            return {"error": "No model currently loaded"}
    except Exception as e:
        logger.error(f"Failed to get embedding model info: {e}")
        return {"error": f"Failed to get model info: {str(e)}"}


@mcp.tool()
async def configure_embedding_model(model_name: str, force_reload: bool = False) -> str:
    """Configure the embedding model to use."""
    embedding_manager = get_embedding_manager()
    try:
        success = embedding_manager.load_model(model_name, force_reload)
        if success:
            model_info = embedding_manager.get_model_info()
            if model_info:
                model_name_info = model_info.get("name", model_name)
                dimension = model_info.get("embedding_dim", "unknown")
                return f"Successfully configured embedding model: {model_name_info} (dim: {dimension})"
            else:
                return f"Model loaded but info unavailable: {model_name}"
        else:
            return f"Failed to load model '{model_name}'. Using ChromaDB default."
    except Exception as e:
        logger.error(f"Failed to configure embedding model: {e}")
        raise Exception(f"Failed to configure embedding model: {str(e)}")


@mcp.tool()
async def chunk_text_intelligent(
    text: str, chunk_size: int = 400, overlap: int = 50
) -> List[str]:
    """Intelligently chunk text for better embedding (Vietnamese optimized)."""
    embedding_manager = get_embedding_manager()
    try:
        # Validate input
        if not isinstance(text, str):
            text = str(text)

        # Ensure valid encoding
        try:
            text.encode("utf-8")
        except UnicodeEncodeError:
            text = text.encode("utf-8", errors="ignore").decode("utf-8")

        chunks = _chunk_text_intelligent(
            text, chunk_size, overlap
        )  # Validate and clean output chunks
        cleaned_chunks = []
        for chunk in chunks:
            if isinstance(chunk, str) and chunk.strip():
                try:
                    chunk.encode("utf-8")
                    cleaned_chunks.append(chunk.strip())
                except UnicodeEncodeError:
                    cleaned_chunk = chunk.encode("utf-8", errors="ignore").decode(
                        "utf-8"
                    )
                    if cleaned_chunk.strip():
                        cleaned_chunks.append(cleaned_chunk.strip())

        return cleaned_chunks
    except Exception as e:
        logger.error(f"Failed to chunk text: {e}")
        raise Exception(f"Failed to chunk text: {str(e)}")


@mcp.tool()
async def get_performance_metrics() -> Dict[str, Any]:
    """Get performance metrics for embedding operations."""
    manager = get_embedding_manager()
    if hasattr(manager, "get_metrics"):
        return manager.get_metrics()
    else:
        return {"message": "Metrics not available", "total_operations": 0}


##### Utility Functions (for compatibility) #####


class MCPTools:
    """
    Legacy compatibility class for existing server.py integration.
    All actual functionality moved to @mcp.tool() functions above.
    """

    def __init__(self):
        """Initialize compatibility layer."""
        pass

    def get_tools_list(self) -> List[Dict[str, Any]]:
        """Get list of available tools for legacy compatibility."""
        # This is now handled by FastMCP automatically
        # Return empty list to maintain compatibility
        return []

    def call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Any:
        """Legacy tool calling interface - deprecated."""
        logger.warning(
            f"Legacy call_tool used for {tool_name} - consider upgrading to FastMCP"
        )
        # Legacy fallback - this should not be used in production
        raise NotImplementedError("Use FastMCP @mcp.tool() functions instead")


# Export the FastMCP instance for server.py
__all__ = ["mcp", "MCPTools"]
