# Generated by Copilot
"""
MCP Server implementation using official MCP standard library
Replaces custom implementation with proper MCP abstractions
"""

import asyncio
import logging
from typing import Dict, Any, List, Optional
from pathlib import Path

try:
    from mcp.server import Server
    from mcp.server import stdio
    from mcp.types import Tool, TextContent
    import mcp.types as types
except ImportError:
    print("âŒ MCP standard library not available. Install with: pip install mcp>=1.0.0")
    raise

from src.config import MCPConfig
from src.embedding.manager import EmbeddingManager
import chromadb
import json

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize MCP Server
app = Server("py-chroma-mcp")

# Global state
config = MCPConfig()
chroma_client = None
embedding_manager = None

async def initialize_components():
    """Initialize ChromaDB and embedding components"""
    global chroma_client, embedding_manager
    
    try:
        # Initialize ChromaDB
        chroma_client = chromadb.PersistentClient(path="./chroma_db")
        logger.info("ChromaDB client initialized successfully")
        
        # Initialize embedding manager
        embedding_manager = EmbeddingManager(config.embedding)
        await embedding_manager.initialize()
        logger.info("Embedding manager initialized")
        
    except Exception as e:
        logger.error(f"Failed to initialize components: {e}")
        raise

@app.tool("echo")
async def echo(message: str) -> str:
    """Echo back a message (useful for testing)"""
    return f"Echo: {message}"

@app.tool("list_collections") 
async def list_collections() -> List[str]:
    """List all ChromaDB collections"""
    try:
        collections = chroma_client.list_collections()
        return [collection.name for collection in collections]
    except Exception as e:
        raise RuntimeError(f"Failed to list collections: {e}")

@app.tool("create_collection")
async def create_collection(name: str, metadata: Optional[Dict[str, Any]] = None) -> str:
    """Create a new ChromaDB collection"""
    try:
        metadata = metadata or {}
        collection = chroma_client.create_collection(
            name=name,
            metadata=metadata
        )
        return f"Collection '{name}' created successfully"
    except Exception as e:
        if "already exists" in str(e):
            raise RuntimeError(f"Collection '{name}' already exists")
        raise RuntimeError(f"Failed to create collection: {e}")

@app.tool("delete_collection")
async def delete_collection(name: str) -> str:
    """Delete a ChromaDB collection"""
    try:
        chroma_client.delete_collection(name=name)
        return f"Collection '{name}' deleted successfully"
    except Exception as e:
        raise RuntimeError(f"Failed to delete collection: {e}")

@app.tool("add_documents")
async def add_documents(
    collection_name: str,
    documents: List[str], 
    ids: Optional[List[str]] = None,
    metadatas: Optional[List[Dict[str, Any]]] = None
) -> str:
    """Add documents to a ChromaDB collection"""
    try:
        # Input validation and cleaning
        if not isinstance(documents, list):
            raise ValueError(f"Documents must be a list, got {type(documents)}")
        
        if not documents:
            raise ValueError("Documents list cannot be empty")
        
        # Clean and validate documents
        cleaned_docs = []
        for i, doc in enumerate(documents):
            if doc is None:
                logger.warning(f"Document {i} is None, skipping")
                continue
            if not isinstance(doc, str):
                logger.warning(f"Document {i} converted from {type(doc)} to string")
                doc = str(doc)
            
            # Clean whitespace and ensure non-empty
            doc = str(doc).strip()
            if doc:
                cleaned_docs.append(doc)
        
        if not cleaned_docs:
            raise ValueError("No valid documents after cleaning")
        
        # Generate IDs if not provided
        if ids is None:
            ids = [f"doc_{i}" for i in range(len(cleaned_docs))]
        elif len(ids) != len(cleaned_docs):
            raise ValueError(f"IDs length ({len(ids)}) must match documents length ({len(cleaned_docs)})")
        
        # Validate metadatas
        if metadatas and len(metadatas) != len(cleaned_docs):
            raise ValueError(f"Metadatas length ({len(metadatas)}) must match documents length ({len(cleaned_docs)})")
        
        # Get collection
        collection = chroma_client.get_collection(name=collection_name)
        
        # Check if we have custom embeddings
        embeddings = None
        if embedding_manager and embedding_manager.model:
            try:
                embeddings = embedding_manager.encode_texts(cleaned_docs)
                embedding_model_name = embedding_manager.get_model_info().get('name', 'unknown')
                logger.info(f"Using custom embeddings from {embedding_model_name}")
            except Exception as e:
                logger.warning(f"Custom embedding failed: {e}, falling back to ChromaDB default")
                embeddings = None
        
        # Add documents
        if embeddings is not None:
            collection.add(
                documents=cleaned_docs,
                embeddings=embeddings.tolist(),
                ids=ids,
                metadatas=metadatas
            )
            return f"Added {len(cleaned_docs)} documents to collection '{collection_name}' using {embedding_model_name} embeddings"
        else:
            collection.add(
                documents=cleaned_docs,
                ids=ids, 
                metadatas=metadatas
            )
            return f"Added {len(cleaned_docs)} documents to collection '{collection_name}' using ChromaDB default embeddings"
            
    except Exception as e:
        raise RuntimeError(f"Failed to add documents: {e}")

@app.tool("query_collection")
async def query_collection(
    collection_name: str,
    query_texts: List[str],
    n_results: int = 10,
    where: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """Query a ChromaDB collection"""
    try:
        if not isinstance(query_texts, list) or not query_texts:
            raise ValueError("query_texts must be a non-empty list")
        
        # Clean query texts
        cleaned_queries = []
        for query in query_texts:
            if isinstance(query, str) and query.strip():
                cleaned_queries.append(query.strip())
        
        if not cleaned_queries:
            raise ValueError("No valid query texts provided")
        
        collection = chroma_client.get_collection(name=collection_name)
        
        # Check if we have custom embeddings
        query_embeddings = None
        if embedding_manager and embedding_manager.model:
            try:
                query_embeddings = embedding_manager.encode_texts(cleaned_queries)
                query_embeddings = query_embeddings.tolist()
            except Exception as e:
                logger.warning(f"Custom query embedding failed: {e}, using text query")
                query_embeddings = None
        
        # Perform query
        if query_embeddings is not None:
            results = collection.query(
                query_embeddings=query_embeddings,
                n_results=n_results,
                where=where,
                include=['metadatas', 'documents', 'distances']
            )
        else:
            results = collection.query(
                query_texts=cleaned_queries,
                n_results=n_results, 
                where=where,
                include=['metadatas', 'documents', 'distances']
            )
        
        return results
        
    except Exception as e:
        raise RuntimeError(f"Failed to query collection: {e}")

@app.tool("get_embedding_model_info")
async def get_embedding_model_info() -> Dict[str, Any]:
    """Get information about current embedding model"""
    try:
        if embedding_manager:
            return embedding_manager.get_model_info()
        else:
            return {
                "name": "chromadb-default",
                "status": "No custom model loaded", 
                "embedding_dim": "Unknown",
                "type": "ChromaDB default"
            }
    except Exception as e:
        raise RuntimeError(f"Failed to get model info: {e}")

@app.tool("configure_embedding_model") 
async def configure_embedding_model(model_name: str, force_reload: bool = False) -> str:
    """Configure the embedding model to use"""
    try:
        if not embedding_manager:
            raise RuntimeError("Embedding manager not initialized")
        
        success = await embedding_manager.load_model(model_name, force_reload)
        
        if success:
            model_info = embedding_manager.get_model_info()
            return f"Successfully loaded model '{model_name}'. Model info: {model_info}"
        else:
            return f"Failed to load model '{model_name}'. Using ChromaDB default."
            
    except Exception as e:
        raise RuntimeError(f"Failed to configure model: {e}")

@app.tool("chunk_text_intelligent")
async def chunk_text_intelligent(
    text: str,
    chunk_size: int = 400,
    overlap: int = 50
) -> List[str]:
    """Intelligently chunk text for better embedding"""
    try:
        if not isinstance(text, str):
            text = str(text)
        
        text = text.strip()
        if not text:
            return []
        
        if embedding_manager:
            return embedding_manager.chunk_text_intelligent(text, chunk_size, overlap)
        else:
            # Fallback simple chunking
            chunks = []
            start = 0
            while start < len(text):
                end = start + chunk_size
                chunk = text[start:end].strip()
                if chunk:
                    chunks.append(chunk)
                start = end - overlap
                if start >= len(text):
                    break
            return chunks
            
    except Exception as e:
        raise RuntimeError(f"Failed to chunk text: {e}")

async def main():
    """Main entry point for the MCP server"""
    try:
        # Initialize components
        await initialize_components()
        
        # Run the server
        async with stdio.stdio_server() as (read_stream, write_stream):
            await app.run(
                read_stream,
                write_stream,
                app.create_initialization_options()
            )
            
    except KeyboardInterrupt:
        logger.info("Server stopped by user")
    except Exception as e:
        logger.error(f"Server error: {e}")
        raise

if __name__ == "__main__":
    asyncio.run(main())
