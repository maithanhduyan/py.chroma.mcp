# Generated by Copilot
from typing import Dict, List, TypedDict, Union, Any
from enum import Enum
import chromadb
from mcp.server.fastmcp import FastMCP
import os
import sys
from dotenv import load_dotenv
import argparse
from chromadb.config import Settings
import ssl
import uuid
import time
import json
from typing_extensions import TypedDict
from pydantic import ValidationError as PydanticValidationError

from utils.logger import get_logger
from embedding.nomic_embedding_function import NomicVietnameseEmbeddingFunction
from models import (
    CreateCollectionRequest,
    AddDocumentsRequest,
    QueryDocumentsRequest,
    GetDocumentsRequest,
    UpdateDocumentsRequest,
    DeleteDocumentsRequest,
    OperationResponse,
    ValidationError,
    normalize_collection_name,
    validate_vietnamese_text,
)

logger = get_logger(__name__)


from chromadb.api.collection_configuration import (
    CreateCollectionConfiguration,
    CreateHNSWConfiguration,
    UpdateHNSWConfiguration,
    UpdateCollectionConfiguration,
)
from chromadb.utils.embedding_functions import (
    DefaultEmbeddingFunction,
    EmbeddingFunction,
)

# Initialize FastMCP server
mcp = FastMCP("chroma")

# Global variables
_chroma_client = None


# Pydantic validation decorators vÃ  helper functions
def handle_pydantic_validation(func):
    """
    Decorator Ä‘á»ƒ xá»­ lÃ½ Pydantic validation errors.

    Args:
        func: Function cáº§n wrap validation

    Returns:
        Wrapped function vá»›i error handling
    """

    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except PydanticValidationError as e:
            # Convert Pydantic errors thÃ nh format dá»… hiá»ƒu
            errors = []
            for error in e.errors():
                field = " -> ".join(str(x) for x in error["loc"])
                errors.append(
                    ValidationError(
                        field=field, message=error["msg"], value=error.get("input")
                    )
                )

            error_msg = f"Validation failed: {len(errors)} error(s)"
            logger.error(f"{error_msg}: {[err.dict() for err in errors]}")

            return OperationResponse(
                success=False,
                message=error_msg,
                data=None,
                error=f"Validation errors in fields: {', '.join([err.field for err in errors])}",
            ).dict()
        except Exception as e:
            logger.error(f"Unexpected error in {func.__name__}: {e}")
            return OperationResponse(
                success=False, message="Internal server error", data=None, error=str(e)
            ).dict()

    return wrapper


def validate_request_data(model_class, data: Dict[str, Any]):
    """
    Validate request data vá»›i Pydantic model.

    Args:
        model_class: Pydantic model class
        data: Data cáº§n validate

    Returns:
        Validated model instance

    Raises:
        PydanticValidationError: Náº¿u validation tháº¥t báº¡i
    """
    try:
        return model_class(**data)
    except PydanticValidationError as e:
        logger.error(f"Validation failed for {model_class.__name__}: {e}")
        raise


def create_parser():
    """Create and return the argument parser."""
    parser = argparse.ArgumentParser(description="FastMCP server for Chroma DB")
    parser.add_argument(
        "--client-type",
        choices=["http", "cloud", "persistent", "ephemeral"],
        default=os.getenv("CHROMA_CLIENT_TYPE", "ephemeral"),
        help="Type of Chroma client to use",
    )
    parser.add_argument(
        "--data-dir",
        default=os.getenv("CHROMA_DATA_DIR"),
        help="Directory for persistent client data (only used with persistent client)",
    )
    parser.add_argument(
        "--host",
        help="Chroma host (required for http client)",
        default=os.getenv("CHROMA_HOST"),
    )
    parser.add_argument(
        "--port",
        help="Chroma port (optional for http client)",
        default=os.getenv("CHROMA_PORT"),
    )
    parser.add_argument(
        "--custom-auth-credentials",
        help="Custom auth credentials (optional for http client)",
        default=os.getenv("CHROMA_CUSTOM_AUTH_CREDENTIALS"),
    )
    parser.add_argument(
        "--tenant",
        help="Chroma tenant (optional for http client)",
        default=os.getenv("CHROMA_TENANT"),
    )
    parser.add_argument(
        "--database",
        help="Chroma database (required if tenant is provided)",
        default=os.getenv("CHROMA_DATABASE"),
    )
    parser.add_argument(
        "--api-key",
        help="Chroma API key (required if tenant is provided)",
        default=os.getenv("CHROMA_API_KEY"),
    )
    parser.add_argument(
        "--ssl",
        help="Use SSL (optional for http client)",
        type=lambda x: x.lower() in ["true", "yes", "1", "t", "y"],
        default=os.getenv("CHROMA_SSL", "true").lower()
        in ["true", "yes", "1", "t", "y"],
    )
    parser.add_argument(
        "--dotenv-path",
        help="Path to .env file",
        default=os.getenv("CHROMA_DOTENV_PATH", ".chroma_env"),
    )
    return parser


def get_chroma_client(args=None):
    """Get or create the global Chroma client instance."""
    global _chroma_client
    if _chroma_client is None:
        if args is None:
            # Create parser and parse args if not provided
            parser = create_parser()
            args = parser.parse_args()

        # Load environment variables from .env file if it exists
        load_dotenv(dotenv_path=args.dotenv_path)
        logger.info(args.dotenv_path)
        if args.client_type == "http":
            if not args.host:
                raise ValueError(
                    "Host must be provided via --host flag or CHROMA_HOST environment variable when using HTTP client"
                )

            settings = Settings()
            if args.custom_auth_credentials:
                settings = Settings(
                    chroma_client_auth_provider="chromadb.auth.basic_authn.BasicAuthClientProvider",
                    chroma_client_auth_credentials=args.custom_auth_credentials,
                )

            # Handle SSL configuration
            try:
                # Ensure port is int if provided, else omit from kwargs
                http_client_kwargs = {
                    "host": args.host,
                    "ssl": args.ssl,
                    "settings": settings,
                }
                if args.port:
                    try:
                        http_client_kwargs["port"] = int(args.port)
                    except ValueError:
                        raise ValueError("Port must be an integer")
                _chroma_client = chromadb.HttpClient(**http_client_kwargs)
            except ssl.SSLError as e:
                logger.info(f"SSL connection failed: {str(e)}")
                raise
            except Exception as e:
                logger.info(f"Error connecting to HTTP client: {str(e)}")
                raise

        elif args.client_type == "cloud":
            if not args.tenant:
                raise ValueError(
                    "Tenant must be provided via --tenant flag or CHROMA_TENANT environment variable when using cloud client"
                )
            if not args.database:
                raise ValueError(
                    "Database must be provided via --database flag or CHROMA_DATABASE environment variable when using cloud client"
                )
            if not args.api_key:
                raise ValueError(
                    "API key must be provided via --api-key flag or CHROMA_API_KEY environment variable when using cloud client"
                )

            try:
                _chroma_client = chromadb.HttpClient(
                    host="api.trychroma.com",
                    ssl=True,  # Always use SSL for cloud
                    tenant=args.tenant,
                    database=args.database,
                    headers={"x-chroma-token": args.api_key},
                )
            except ssl.SSLError as e:
                logger.info(f"SSL connection failed: {str(e)}")
                raise
            except Exception as e:
                logger.info(f"Error connecting to cloud client: {str(e)}")
                raise

        elif args.client_type == "persistent":
            # Use persistent client with SQLite backend
            if not args.data_dir:
                raise ValueError(
                    "Data directory must be provided via --data-dir flag when using persistent client"
                )
            # ChromaDB persistent client uses SQLite by default if available
            _chroma_client = chromadb.PersistentClient(path=args.data_dir)
        else:  # ephemeral
            _chroma_client = chromadb.EphemeralClient()

    return _chroma_client


##### Collection Tools #####
@mcp.tool()
async def echo(message: str) -> str:
    """Pháº£n há»“i láº¡i thÃ´ng Ä‘iá»‡p Ä‘áº§u vÃ o (há»¯u Ã­ch Ä‘á»ƒ kiá»ƒm tra)."""
    return f"Echo: {message}"


@mcp.tool()
async def list_collections(
    limit: int | None = None, offset: int | None = None
) -> List[str]:
    """Liá»‡t kÃª táº¥t cáº£ cÃ¡c tÃªn collection trong cÆ¡ sá»Ÿ dá»¯ liá»‡u Chroma vá»›i há»— trá»£ phÃ¢n trang.

    Tham sá»‘:
        limit: Sá»‘ lÆ°á»£ng tá»‘i Ä‘a cÃ¡c collection cáº§n tráº£ vá» (tÃ¹y chá»n).
        offset: Sá»‘ lÆ°á»£ng collection cáº§n bá» qua trÆ°á»›c khi tráº£ vá» káº¿t quáº£ (tÃ¹y chá»n).

    Tráº£ vá»:
        Danh sÃ¡ch cÃ¡c tÃªn collection hoáº·c ["__NO_COLLECTIONS_FOUND__"] náº¿u cÆ¡ sá»Ÿ dá»¯ liá»‡u trá»‘ng.
    """
    client = get_chroma_client()
    try:
        colls = client.list_collections(limit=limit, offset=offset)
        # Safe handling: If colls is None or empty, return a special marker
        if not colls:
            return ["__NO_COLLECTIONS_FOUND__"]
        # Otherwise iterate to get collection names
        return [coll.name for coll in colls]

    except Exception as e:
        raise Exception(f"Failed to list collections: {str(e)}") from e


# Lazy loading cache cho embedding functions Ä‘á»ƒ tÄƒng hiá»‡u suáº¥t startup
_embedding_function_cache: Dict[str, EmbeddingFunction] = {}


def get_embedding_function(name: str = "default") -> EmbeddingFunction:
    """
    Lazy load embedding function Ä‘á»ƒ tá»‘i Æ°u hiá»‡u suáº¥t khá»Ÿi Ä‘á»™ng server.

    Args:
        name: TÃªn embedding function ('default', 'nomic_vietnamese')

    Returns:
        EmbeddingFunction instance
    """
    if name in _embedding_function_cache:
        logger.debug(f"Using cached embedding function: {name}")
        return _embedding_function_cache[name]

    logger.info(
        f"Loading embedding function: {name} (first time, may take a moment...)"
    )

    try:
        if name == "default":
            embedding_fn = DefaultEmbeddingFunction()
        elif name == "nomic_vietnamese":
            embedding_fn = NomicVietnameseEmbeddingFunction()
        else:
            logger.warning(
                f"Unknown embedding function: {name}, falling back to default"
            )
            embedding_fn = DefaultEmbeddingFunction()

        # Cache Ä‘á»ƒ trÃ¡nh load láº¡i
        _embedding_function_cache[name] = embedding_fn
        logger.info(f"Successfully loaded and cached embedding function: {name}")
        return embedding_fn

    except Exception as e:
        logger.error(f"Failed to load embedding function {name}: {e}")
        logger.info("Falling back to DefaultEmbeddingFunction")
        if "default" not in _embedding_function_cache:
            _embedding_function_cache["default"] = DefaultEmbeddingFunction()
        return _embedding_function_cache["default"]


def preload_embedding_functions(*names: str) -> None:
    """
    Preload embedding functions Ä‘á»ƒ tá»‘i Æ°u hiá»‡u suáº¥t.
    Há»¯u Ã­ch cho production environments khi muá»‘n load models trÆ°á»›c.

    Args:
        *names: TÃªn cÃ¡c embedding function cáº§n preload
    """
    logger.info(f"Preloading embedding functions: {names}")

    for name in names:
        try:
            get_embedding_function(name)
            logger.info(f"âœ… Preloaded: {name}")
        except Exception as e:
            logger.error(f"âŒ Failed to preload {name}: {e}")


def clear_embedding_cache() -> None:
    """
    XÃ³a cache embedding functions Ä‘á»ƒ giáº£i phÃ³ng memory náº¿u cáº§n.
    """
    global _embedding_function_cache
    cache_count = len(_embedding_function_cache)
    _embedding_function_cache.clear()
    logger.info(f"Cleared embedding function cache ({cache_count} functions removed)")


def get_cached_embedding_functions() -> List[str]:
    """
    Láº¥y danh sÃ¡ch cÃ¡c embedding functions Ä‘Ã£ Ä‘Æ°á»£c cache.

    Returns:
        List tÃªn cÃ¡c embedding function Ä‘Ã£ cache
    """
    return list(_embedding_function_cache.keys())


@mcp.tool()
async def create_collection(
    collection_name: str,
    embedding_function_name: str = "default",
    metadata: Dict | None = None,
    space: str | None = None,
    ef_construction: int | None = None,
    ef_search: int | None = None,
    max_neighbors: int | None = None,
    num_threads: int | None = None,
    batch_size: int | None = None,
    sync_threshold: int | None = None,
    resize_factor: float | None = None,
) -> str:
    """Táº¡o má»™t collection má»›i trong Chroma vá»›i cÃ¡c tham sá»‘ HNSW cÃ³ thá»ƒ cáº¥u hÃ¬nh.

    Tham sá»‘:
        collection_name: TÃªn cá»§a collection cáº§n táº¡o.
        space: HÃ m khoáº£ng cÃ¡ch Ä‘Æ°á»£c sá»­ dá»¥ng trong chá»‰ má»¥c HNSW. CÃ¡c tÃ¹y chá»n: 'l2', 'ip', 'cosine'.
        ef_construction: KÃ­ch thÆ°á»›c danh sÃ¡ch á»©ng viÃªn Ä‘á»™ng Ä‘á»ƒ xÃ¢y dá»±ng Ä‘á»“ thá»‹ HNSW.
        ef_search: KÃ­ch thÆ°á»›c danh sÃ¡ch á»©ng viÃªn Ä‘á»™ng Ä‘á»ƒ tÃ¬m kiáº¿m trong Ä‘á»“ thá»‹ HNSW.
        max_neighbors: Sá»‘ lÆ°á»£ng hÃ ng xÃ³m tá»‘i Ä‘a Ä‘Æ°á»£c xem xÃ©t trong quÃ¡ trÃ¬nh xÃ¢y dá»±ng Ä‘á»“ thá»‹ HNSW.
        num_threads: Sá»‘ lÆ°á»£ng luá»“ng Ä‘Æ°á»£c sá»­ dá»¥ng trong quÃ¡ trÃ¬nh xÃ¢y dá»±ng HNSW.
        batch_size: Sá»‘ lÆ°á»£ng pháº§n tá»­ Ä‘Æ°á»£c xá»­ lÃ½ cÃ¹ng lÃºc trong quÃ¡ trÃ¬nh xÃ¢y dá»±ng chá»‰ má»¥c.
        sync_threshold: Sá»‘ lÆ°á»£ng pháº§n tá»­ cáº§n xá»­ lÃ½ trÆ°á»›c khi Ä‘á»“ng bá»™ chá»‰ má»¥c vá»›i Ä‘Ä©a.
        resize_factor: Há»‡ sá»‘ má»Ÿ rá»™ng chá»‰ má»¥c khi nÃ³ Ä‘áº§y.        embedding_function_name: TÃªn cá»§a hÃ m nhÃºng Ä‘Æ°á»£c sá»­ dá»¥ng. CÃ¡c tÃ¹y chá»n: 'default', 'nomic_vietnamese'.
        metadata: Tá»« Ä‘iá»ƒn metadata tÃ¹y chá»n Ä‘á»ƒ thÃªm vÃ o collection.
    """
    client = get_chroma_client()

    embedding_function = get_embedding_function(embedding_function_name)
    hnsw_config = CreateHNSWConfiguration()
    if space:
        if space in ("l2", "ip", "cosine"):
            hnsw_config["space"] = space
        else:
            raise ValueError("space must be one of: 'l2', 'ip', 'cosine'")
    if ef_construction:
        hnsw_config["ef_construction"] = ef_construction
    if ef_search:
        hnsw_config["ef_search"] = ef_search
    if max_neighbors:
        hnsw_config["max_neighbors"] = max_neighbors
    if num_threads:
        hnsw_config["num_threads"] = num_threads
    if batch_size:
        hnsw_config["batch_size"] = batch_size
    if sync_threshold:
        hnsw_config["sync_threshold"] = sync_threshold
    if resize_factor:
        hnsw_config["resize_factor"] = resize_factor

    configuration = CreateCollectionConfiguration(
        hnsw=hnsw_config, embedding_function=embedding_function
    )

    try:
        client.create_collection(
            name=collection_name, configuration=configuration, metadata=metadata
        )
        config_msg = f" with configuration: {configuration}"
        return f"Successfully created collection {collection_name}{config_msg}"
    except Exception as e:
        raise Exception(
            f"Failed to create collection '{collection_name}': {str(e)}"
        ) from e


@mcp.tool()
async def peek_collection(collection_name: str, limit: int = 5) -> Dict:
    """Xem trÆ°á»›c cÃ¡c tÃ i liá»‡u trong má»™t collection cá»§a Chroma.

    Tham sá»‘:
        collection_name: TÃªn cá»§a collection cáº§n xem trÆ°á»›c.
        limit: Sá»‘ lÆ°á»£ng tÃ i liá»‡u cáº§n xem trÆ°á»›c.
    """
    client = get_chroma_client()
    try:
        collection = client.get_collection(collection_name)
        results = collection.peek(limit=limit)
        # Convert GetResult to dict for type compatibility
        return dict(results)
    except Exception as e:
        raise Exception(
            f"Failed to peek collection '{collection_name}': {str(e)}"
        ) from e


@mcp.tool()
async def get_collection_info(collection_name: str) -> Dict:
    """Láº¥y thÃ´ng tin vá» má»™t collection trong Chroma.

    Tham sá»‘:
        collection_name: TÃªn cá»§a collection cáº§n láº¥y thÃ´ng tin.
    """
    client = get_chroma_client()
    try:
        collection = client.get_collection(collection_name)

        # Get collection count
        count = collection.count()

        # Peek at a few documents
        peek_results = collection.peek(limit=3)

        return {
            "name": collection_name,
            "count": count,
            "sample_documents": peek_results,
        }
    except Exception as e:
        raise Exception(
            f"Failed to get collection info for '{collection_name}': {str(e)}"
        ) from e


@mcp.tool()
async def get_collection_count(collection_name: str) -> int:
    """Láº¥y sá»‘ lÆ°á»£ng tÃ i liá»‡u trong má»™t collection cá»§a Chroma.

    Tham sá»‘:
        collection_name: TÃªn cá»§a collection cáº§n Ä‘áº¿m.
    """
    client = get_chroma_client()
    try:
        collection = client.get_collection(collection_name)
        return collection.count()
    except Exception as e:
        raise Exception(
            f"Failed to get collection count for '{collection_name}': {str(e)}"
        ) from e


@mcp.tool()
async def modify_collection(
    collection_name: str,
    new_name: str | None = None,
    new_metadata: Dict | None = None,
    ef_search: int | None = None,
    num_threads: int | None = None,
    batch_size: int | None = None,
    sync_threshold: int | None = None,
    resize_factor: float | None = None,
) -> str:
    """Chá»‰nh sá»­a tÃªn hoáº·c metadata cá»§a má»™t collection trong Chroma.

    Tham sá»‘:
        collection_name: TÃªn cá»§a collection cáº§n chá»‰nh sá»­a.
        new_name: TÃªn má»›i cho collection (tÃ¹y chá»n).
        new_metadata: Metadata má»›i cho collection (tÃ¹y chá»n).
        ef_search: KÃ­ch thÆ°á»›c danh sÃ¡ch á»©ng viÃªn Ä‘á»™ng Ä‘á»ƒ tÃ¬m kiáº¿m trong Ä‘á»“ thá»‹ HNSW.
        num_threads: Sá»‘ lÆ°á»£ng luá»“ng Ä‘Æ°á»£c sá»­ dá»¥ng trong quÃ¡ trÃ¬nh xÃ¢y dá»±ng HNSW.
        batch_size: Sá»‘ lÆ°á»£ng pháº§n tá»­ Ä‘Æ°á»£c xá»­ lÃ½ cÃ¹ng lÃºc trong quÃ¡ trÃ¬nh xÃ¢y dá»±ng chá»‰ má»¥c.
        sync_threshold: Sá»‘ lÆ°á»£ng pháº§n tá»­ cáº§n xá»­ lÃ½ trÆ°á»›c khi Ä‘á»“ng bá»™ chá»‰ má»¥c vá»›i Ä‘Ä©a.
        resize_factor: Há»‡ sá»‘ má»Ÿ rá»™ng chá»‰ má»¥c khi nÃ³ Ä‘áº§y.
    """
    client = get_chroma_client()
    try:
        collection = client.get_collection(collection_name)

        hnsw_config = UpdateHNSWConfiguration()
        if ef_search:
            hnsw_config["ef_search"] = ef_search
        if num_threads:
            hnsw_config["num_threads"] = num_threads
        if batch_size:
            hnsw_config["batch_size"] = batch_size
        if sync_threshold:
            hnsw_config["sync_threshold"] = sync_threshold
        if resize_factor:
            hnsw_config["resize_factor"] = resize_factor

        configuration = UpdateCollectionConfiguration(hnsw=hnsw_config)
        collection.modify(
            name=new_name, configuration=configuration, metadata=new_metadata
        )

        modified_aspects = []
        if new_name:
            modified_aspects.append("name")
        if new_metadata:
            modified_aspects.append("metadata")
        if ef_search or num_threads or batch_size or sync_threshold or resize_factor:
            modified_aspects.append("hnsw")

        return f"Successfully modified collection {collection_name}: updated {' and '.join(modified_aspects)}"
    except Exception as e:
        raise Exception(
            f"Failed to modify collection '{collection_name}': {str(e)}"
        ) from e


@mcp.tool()
async def delete_collection(collection_name: str) -> str:
    """XÃ³a má»™t collection trong Chroma.

    Tham sá»‘:
        collection_name: TÃªn cá»§a collection cáº§n xÃ³a.
    """
    client = get_chroma_client()
    try:
        client.delete_collection(collection_name)
        return f"Successfully deleted collection {collection_name}"
    except Exception as e:
        raise Exception(
            f"Failed to delete collection '{collection_name}': {str(e)}"
        ) from e


##### Document Tools #####
@mcp.tool()
@handle_pydantic_validation
async def add_documents(
    collection_name: str,
    documents: List[str],
    ids: List[str],
    metadatas: List[Dict] | None = None,
) -> str:
    """ThÃªm tÃ i liá»‡u vÃ o má»™t collection cá»§a Chroma.

    Tham sá»‘:
        collection_name: TÃªn cá»§a collection cáº§n thÃªm tÃ i liá»‡u.
        documents: Danh sÃ¡ch cÃ¡c tÃ i liá»‡u vÄƒn báº£n cáº§n thÃªm.
        ids: Danh sÃ¡ch cÃ¡c ID cho cÃ¡c tÃ i liá»‡u (báº¯t buá»™c).
        metadatas: Danh sÃ¡ch metadata tÃ¹y chá»n cho má»—i tÃ i liá»‡u.
    """
    # Validate input using Pydantic model
    request_data = {
        "collection_name": collection_name,
        "documents": documents,
        "ids": ids,
        "metadatas": metadatas,
    }

    validated_request = validate_request_data(AddDocumentsRequest, request_data)

    client = get_chroma_client()
    try:
        collection = client.get_or_create_collection(validated_request.collection_name)

        # Check for duplicate IDs
        existing_ids = collection.get(include=[])["ids"]
        duplicate_ids = [id for id in validated_request.ids if id in existing_ids]

        if duplicate_ids:
            raise ValueError(
                f"The following IDs already exist in collection '{validated_request.collection_name}': {duplicate_ids}. "
                f"Use 'chroma_update_documents' to update existing documents."
            )  # Convert Pydantic models to dict if needed
        metadatas_dict = None
        if validated_request.metadatas:
            metadatas_dict = []
            for metadata in validated_request.metadatas:
                if hasattr(metadata, "model_dump"):
                    # Pydantic model
                    metadatas_dict.append(metadata.model_dump())
                elif isinstance(metadata, dict):
                    # Already a dict
                    metadatas_dict.append(metadata)
                else:
                    # Convert to dict
                    metadatas_dict.append(dict(metadata))

        result = collection.add(
            documents=validated_request.documents,
            metadatas=metadatas_dict,
            ids=validated_request.ids,
        )

        # Check the return value
        if result and isinstance(result, dict):
            # If the return value is a dictionary, it may contain success information
            if "success" in result and not result["success"]:
                raise Exception(
                    f"Failed to add documents: {result.get('error', 'Unknown error')}"
                )

            # If the return value contains the actual number added
            if "count" in result:
                return f"Successfully added {result['count']} documents to collection {validated_request.collection_name}"

        # Default return
        return f"Successfully added {len(validated_request.documents)} documents to collection {validated_request.collection_name}, result is {result}"
    except Exception as e:
        raise Exception(
            f"Failed to add documents to collection '{validated_request.collection_name}': {str(e)}"
        ) from e


@mcp.tool()
@handle_pydantic_validation
async def query_documents(
    collection_name: str,
    query_texts: List[str],
    n_results: int = 5,
    where: Dict | None = None,
    where_document: Dict | None = None,
    include: List[str] = ["documents", "metadatas", "distances"],
) -> Dict:
    """Truy váº¥n tÃ i liá»‡u tá»« má»™t collection cá»§a Chroma vá»›i cÃ¡c bá»™ lá»c nÃ¢ng cao.

    Tham sá»‘:
        collection_name: TÃªn cá»§a collection cáº§n truy váº¥n.
        query_texts: Danh sÃ¡ch cÃ¡c vÄƒn báº£n truy váº¥n Ä‘á»ƒ tÃ¬m kiáº¿m.
        n_results: Sá»‘ lÆ°á»£ng káº¿t quáº£ cáº§n tráº£ vá» cho má»—i truy váº¥n.
        where: Bá»™ lá»c metadata tÃ¹y chá»n sá»­ dá»¥ng cÃ¡c toÃ¡n tá»­ truy váº¥n cá»§a Chroma.
               VÃ­ dá»¥:
               - So sÃ¡nh Ä‘Æ¡n giáº£n: {"metadata_field": "value"}
               - So sÃ¡nh: {"metadata_field": {"$gt": 5}}
               - AND logic: {"$and": [{"field1": {"$eq": "value1"}}, {"field2": {"$gt": 5}}]}
               - OR logic: {"$or": [{"field1": {"$eq": "value1"}}, {"field1": {"$eq": "value2"}}]}
        where_document: Bá»™ lá»c ná»™i dung tÃ i liá»‡u tÃ¹y chá»n.
        include: Danh sÃ¡ch cÃ¡c thÃ´ng tin cáº§n bao gá»“m trong káº¿t quáº£. Máº·c Ä‘á»‹nh bao gá»“m tÃ i liá»‡u, metadata vÃ  khoáº£ng cÃ¡ch.
    """
    # Validate input using Pydantic model
    request_data = {
        "collection_name": collection_name,
        "query_texts": query_texts,
        "n_results": n_results,
        "include": include,
        "where": where,
        "where_document": where_document,
    }

    validated_request = validate_request_data(QueryDocumentsRequest, request_data)

    client = get_chroma_client()
    try:
        collection = client.get_collection(validated_request.collection_name)
        results = collection.query(
            query_texts=validated_request.query_texts,
            n_results=validated_request.n_results,
            where=validated_request.where,  # type: ignore
            where_document=validated_request.where_document,  # type: ignore
            include=validated_request.include,  # type: ignore
        )
        return dict(results)  # Convert QueryResult to dict
    except Exception as e:
        raise Exception(
            f"Failed to query documents from collection '{validated_request.collection_name}': {str(e)}"
        ) from e


@mcp.tool()
async def get_documents(
    collection_name: str,
    ids: List[str] | None = None,
    where: Dict | None = None,
    where_document: Dict | None = None,
    include: List[str] = ["documents", "metadatas"],
    limit: int | None = None,
    offset: int | None = None,
) -> Dict:
    """Láº¥y tÃ i liá»‡u tá»« má»™t collection cá»§a Chroma vá»›i cÃ¡c bá»™ lá»c tÃ¹y chá»n.

    Tham sá»‘:
        collection_name: TÃªn cá»§a collection cáº§n láº¥y tÃ i liá»‡u.
        ids: Danh sÃ¡ch cÃ¡c ID tÃ i liá»‡u cáº§n láº¥y (tÃ¹y chá»n).
        where: Bá»™ lá»c metadata tÃ¹y chá»n sá»­ dá»¥ng cÃ¡c toÃ¡n tá»­ truy váº¥n cá»§a Chroma.
               VÃ­ dá»¥:
               - So sÃ¡nh Ä‘Æ¡n giáº£n: {"metadata_field": "value"}
               - So sÃ¡nh: {"metadata_field": {"$gt": 5}}
               - AND logic: {"$and": [{"field1": {"$eq": "value1"}}, {"field2": {"$gt": 5}}]}
               - OR logic: {"$or": [{"field1": {"$eq": "value1"}}, {"field1": {"$eq": "value2"}}]}
        where_document: Bá»™ lá»c ná»™i dung tÃ i liá»‡u tÃ¹y chá»n.
        include: Danh sÃ¡ch cÃ¡c thÃ´ng tin cáº§n bao gá»“m trong káº¿t quáº£. Máº·c Ä‘á»‹nh bao gá»“m tÃ i liá»‡u vÃ  metadata.
        limit: Sá»‘ lÆ°á»£ng tÃ i liá»‡u tá»‘i Ä‘a cáº§n tráº£ vá» (tÃ¹y chá»n).
        offset: Sá»‘ lÆ°á»£ng tÃ i liá»‡u cáº§n bá» qua trÆ°á»›c khi tráº£ vá» káº¿t quáº£ (tÃ¹y chá»n).

    Tráº£ vá»:
        Tá»« Ä‘iá»ƒn chá»©a cÃ¡c tÃ i liá»‡u phÃ¹ há»£p, ID cá»§a chÃºng vÃ  cÃ¡c thÃ´ng tin Ä‘Æ°á»£c yÃªu cáº§u.
    """
    client = get_chroma_client()
    try:
        collection = client.get_collection(collection_name)
        results = collection.get(
            ids=ids,
            where=where,
            where_document=where_document,
            include=include,  # type: ignore
            limit=limit,
            offset=offset,
        )
        return dict(results)  # Convert GetResult to dict
    except Exception as e:
        raise Exception(
            f"Failed to get documents from collection '{collection_name}': {str(e)}"
        ) from e


@mcp.tool()
async def update_documents(
    collection_name: str,
    ids: List[str],
    embeddings: List[List[float]] | None = None,
    metadatas: List[Dict] | None = None,
    documents: List[str] | None = None,
) -> str:
    """Cáº­p nháº­t tÃ i liá»‡u trong má»™t collection cá»§a Chroma.

    Tham sá»‘:
        collection_name: TÃªn cá»§a collection cáº§n cáº­p nháº­t tÃ i liá»‡u.
        ids: Danh sÃ¡ch cÃ¡c ID tÃ i liá»‡u cáº§n cáº­p nháº­t (báº¯t buá»™c).
        embeddings: Danh sÃ¡ch nhÃºng má»›i cho cÃ¡c tÃ i liá»‡u (tÃ¹y chá»n).
        metadatas: Danh sÃ¡ch metadata má»›i cho cÃ¡c tÃ i liá»‡u (tÃ¹y chá»n).
        documents: Danh sÃ¡ch cÃ¡c tÃ i liá»‡u vÄƒn báº£n má»›i (tÃ¹y chá»n).

    Tráº£ vá»:
        ThÃ´ng bÃ¡o xÃ¡c nháº­n sá»‘ lÆ°á»£ng tÃ i liá»‡u Ä‘Ã£ Ä‘Æ°á»£c cáº­p nháº­t.

    Ngoáº¡i lá»‡:
        ValueError: Náº¿u 'ids' trá»‘ng hoáº·c khÃ´ng cÃ³ 'embeddings', 'metadatas', hoáº·c 'documents' Ä‘Æ°á»£c cung cáº¥p.
        Exception: Náº¿u collection khÃ´ng tá»“n táº¡i hoáº·c náº¿u thao tÃ¡c cáº­p nháº­t tháº¥t báº¡i.
    """
    if not ids:
        raise ValueError("The 'ids' list cannot be empty.")

    if embeddings is None and metadatas is None and documents is None:
        raise ValueError(
            "At least one of 'embeddings', 'metadatas', or 'documents' "
            "must be provided for update."
        )

    # Ensure provided lists match the length of ids if they are not None
    if embeddings is not None and len(embeddings) != len(ids):
        raise ValueError("Length of 'embeddings' list must match length of 'ids' list.")
    if metadatas is not None and len(metadatas) != len(ids):
        raise ValueError("Length of 'metadatas' list must match length of 'ids' list.")
    if documents is not None and len(documents) != len(ids):
        raise ValueError("Length of 'documents' list must match length of 'ids' list.")

    client = get_chroma_client()
    try:
        collection = client.get_collection(collection_name)
    except Exception as e:
        raise Exception(
            f"Failed to get collection '{collection_name}': {str(e)}"
        ) from e

    # Prepare arguments for update, excluding None values at the top level
    update_args = {
        "ids": ids,
        "embeddings": embeddings,
        "metadatas": metadatas,
        "documents": documents,
    }
    kwargs = {k: v for k, v in update_args.items() if v is not None}

    try:
        collection.update(**kwargs)
        return (
            f"Successfully processed update request for {len(ids)} documents in "
            f"collection '{collection_name}'. Note: Non-existent IDs are ignored by ChromaDB."
        )
    except Exception as e:
        raise Exception(
            f"Failed to update documents in collection '{collection_name}': {str(e)}"
        ) from e


@mcp.tool()
async def delete_documents(collection_name: str, ids: List[str]) -> str:
    """XÃ³a tÃ i liá»‡u khá»i má»™t collection cá»§a Chroma.

    Tham sá»‘:
        collection_name: TÃªn cá»§a collection cáº§n xÃ³a tÃ i liá»‡u.
        ids: Danh sÃ¡ch cÃ¡c ID tÃ i liá»‡u cáº§n xÃ³a.
    """
    if not ids:
        raise ValueError("The 'ids' list cannot be empty.")

    client = get_chroma_client()
    try:
        collection = client.get_collection(collection_name)
    except Exception as e:
        raise Exception(
            f"Failed to get collection '{collection_name}': {str(e)}"
        ) from e

    try:
        collection.delete(ids=ids)
        return (
            f"Successfully deleted {len(ids)} documents from "
            f"collection '{collection_name}'. Note: Non-existent IDs are ignored by ChromaDB."
        )
    except Exception as e:
        raise Exception(
            f"Failed to delete documents from collection '{collection_name}': {str(e)}"
        ) from e


def validate_thought_data(input_data: Dict) -> Dict:
    """Validate thought data structure."""
    if not input_data.get("sessionId"):
        raise ValueError("Invalid sessionId: must be provided")
    if not input_data.get("thought") or not isinstance(input_data.get("thought"), str):
        raise ValueError("Invalid thought: must be a string")
    if not input_data.get("thoughtNumber") or not isinstance(
        input_data.get("thoughtNumber"), int
    ):
        raise ValueError("Invalid thoughtNumber: must be a number")
    if not input_data.get("totalThoughts") or not isinstance(
        input_data.get("totalThoughts"), int
    ):
        raise ValueError("Invalid totalThoughts: must be a number")
    if not isinstance(input_data.get("nextThoughtNeeded"), bool):
        raise ValueError("Invalid nextThoughtNeeded: must be a boolean")

    return {
        "sessionId": input_data.get("sessionId"),
        "thought": input_data.get("thought"),
        "thoughtNumber": input_data.get("thoughtNumber"),
        "totalThoughts": input_data.get("totalThoughts"),
        "nextThoughtNeeded": input_data.get("nextThoughtNeeded"),
        "isRevision": input_data.get("isRevision"),
        "revisesThought": input_data.get("revisesThought"),
        "branchFromThought": input_data.get("branchFromThought"),
        "branchId": input_data.get("branchId"),
        "needsMoreThoughts": input_data.get("needsMoreThoughts"),
    }


def process_thought(input_data: Dict) -> Dict:
    """Process a new thought."""
    try:
        # Validate input data
        validated_input = validate_thought_data(input_data)

        # Adjust total thoughts if needed
        if validated_input["thoughtNumber"] > validated_input["totalThoughts"]:
            validated_input["totalThoughts"] = validated_input["thoughtNumber"]

        # Return response
        return {
            "sessionId": validated_input["sessionId"],
            "thoughtNumber": validated_input["thoughtNumber"],
            "totalThoughts": validated_input["totalThoughts"],
            "nextThoughtNeeded": validated_input["nextThoughtNeeded"],
        }

    except Exception as e:
        return {"error": str(e), "status": "failed"}


def main():
    """Main entry point for the MCP server."""
    parser = create_parser()
    args = parser.parse_args()

    try:
        # Initialize Chroma client
        get_chroma_client(args)
        logger.info("âœ… Loading Chroma client...")
        logger.info(f"ðŸ”§ Server args: {str(args)}")

        # Initialize and run the server
        logger.info("ðŸš€ Starting FastMCP ChromaDB Server...")
        mcp.run(transport="stdio")

    except KeyboardInterrupt:
        logger.info("\nðŸ›‘ Server shutdown requested by user")
    except Exception as e:
        logger.error(f"ðŸ’¥ Server startup failed: {e}")
        logger.exception("Server startup error details:")
        sys.exit(1)
    finally:
        logger.info("ðŸ”š FastMCP ChromaDB Server stopped")


if __name__ == "__main__":
    main()
