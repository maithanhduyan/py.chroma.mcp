# Generated by Copilot
"""
Input validation utilities for ChromaDB MCP server.

This module provides validation for ChromaDB operations including:
- Collection name validation
- Document validation
- Query parameter validation
- Input sanitization
"""

import re
import json
import logging
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass

logger = logging.getLogger(__name__)

# Constants
MAX_COLLECTION_NAME_LENGTH = 63
MAX_DOCUMENT_SIZE = 1024 * 1024  # 1MB
MAX_DOCUMENTS_PER_BATCH = 1000


@dataclass
class ValidationResult:
    """Result of input validation with detailed feedback."""

    is_valid: bool
    errors: List[str]
    warnings: List[str]
    sanitized_data: Optional[Any] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert validation result to dictionary."""
        return {
            "is_valid": self.is_valid,
            "errors": self.errors,
            "warnings": self.warnings,
            "sanitized_data": self.sanitized_data,
        }


class InputValidator:
    """Base validator class with common validation utilities."""

    def __init__(self) -> None:
        """Initialize validator."""
        self.validation_count = 0
        self.error_count = 0
        logger.debug("ðŸ”§ InputValidator initialized")

    def _create_result(self, is_valid: bool = True) -> ValidationResult:
        """Create new validation result."""
        self.validation_count += 1
        if not is_valid:
            self.error_count += 1

        return ValidationResult(is_valid=is_valid, errors=[], warnings=[])

    def get_validation_stats(self) -> Dict[str, Union[int, float]]:
        """Get validation statistics."""
        return {
            "total_validations": self.validation_count,
            "total_errors": self.error_count,
            "success_rate": (self.validation_count - self.error_count)
            / max(self.validation_count, 1),
        }


class CollectionValidator(InputValidator):
    """Validator for ChromaDB collection operations."""

    def validate_collection_name(self, name: str) -> ValidationResult:
        """Validate collection name according to ChromaDB requirements."""
        result = self._create_result()

        if not isinstance(name, str):
            result.is_valid = False
            result.errors.append("Collection name must be a string")
            return result

        if len(name) == 0:
            result.is_valid = False
            result.errors.append("Collection name cannot be empty")
            return result

        if len(name) > MAX_COLLECTION_NAME_LENGTH:
            result.is_valid = False
            result.errors.append(
                f"Collection name exceeds maximum length of {MAX_COLLECTION_NAME_LENGTH}"
            )
            return result

        if not re.match(r"^[a-zA-Z0-9_-]+$", name):
            result.is_valid = False
            result.errors.append(
                "Collection name can only contain letters, numbers, underscores, and hyphens"
            )
            return result

        if name.startswith("_"):
            result.warnings.append(
                "Collection names starting with underscore are reserved"
            )

        result.sanitized_data = name.lower()
        logger.debug(f"âœ… Collection name '{name}' validated successfully")
        return result

    def validate_metadata(self, metadata: Optional[Dict[str, Any]]) -> ValidationResult:
        """Validate collection metadata."""
        result = self._create_result()

        if metadata is None:
            result.sanitized_data = {}
            return result

        if not isinstance(metadata, dict):
            result.is_valid = False
            result.errors.append("Metadata must be a dictionary")
            return result

        result.sanitized_data = metadata
        logger.debug(f"âœ… Metadata validated with {len(metadata)} fields")
        return result


class DocumentValidator(InputValidator):
    """Validator for document operations."""

    def validate_documents(self, documents: List[str]) -> ValidationResult:
        """Validate list of documents."""
        result = self._create_result()

        if not isinstance(documents, list):
            result.is_valid = False
            result.errors.append("Documents must be provided as a list")
            return result

        if len(documents) == 0:
            result.is_valid = False
            result.errors.append("Documents list cannot be empty")
            return result

        if len(documents) > MAX_DOCUMENTS_PER_BATCH:
            result.is_valid = False
            result.errors.append(
                f"Too many documents: {len(documents)} > {MAX_DOCUMENTS_PER_BATCH}"
            )
            return result

        sanitized_docs = []
        for i, doc in enumerate(documents):
            if not isinstance(doc, str):
                result.errors.append(f"Document at index {i} must be a string")
                continue

            if len(doc.encode("utf-8")) > MAX_DOCUMENT_SIZE:
                result.errors.append(f"Document at index {i} exceeds maximum size")
                continue

            sanitized_doc = doc.strip()
            if not sanitized_doc:
                result.warnings.append(
                    f"Document at index {i} is empty after sanitization"
                )
                continue

            sanitized_docs.append(sanitized_doc)

        if result.errors:
            result.is_valid = False
        else:
            result.sanitized_data = sanitized_docs
            logger.debug(f"âœ… Validated {len(sanitized_docs)} documents successfully")

        return result


class QueryValidator(InputValidator):
    """Validator for query operations."""

    def validate_query_texts(self, query_texts: List[str]) -> ValidationResult:
        """Validate query text list."""
        result = self._create_result()

        if not isinstance(query_texts, list):
            result.is_valid = False
            result.errors.append("Query texts must be provided as a list")
            return result

        if len(query_texts) == 0:
            result.is_valid = False
            result.errors.append("Query texts list cannot be empty")
            return result

        sanitized_queries = []
        for i, query in enumerate(query_texts):
            if not isinstance(query, str):
                result.errors.append(f"Query at index {i} must be a string")
                continue

            sanitized_query = query.strip()
            if not sanitized_query:
                result.errors.append(f"Query at index {i} cannot be empty")
                continue

            sanitized_queries.append(sanitized_query)

        if result.errors:
            result.is_valid = False
        else:
            result.sanitized_data = sanitized_queries
            logger.debug(
                f"âœ… Validated {len(sanitized_queries)} query texts successfully"
            )

        return result

    def validate_n_results(self, n_results: int) -> ValidationResult:
        """Validate number of results parameter."""
        result = self._create_result()

        if not isinstance(n_results, int):
            try:
                n_results = int(n_results)
            except (ValueError, TypeError):
                result.is_valid = False
                result.errors.append("n_results must be an integer")
                return result

        if n_results <= 0:
            result.is_valid = False
            result.errors.append("n_results must be a positive integer")
            return result

        if n_results > 1000:
            result.warnings.append(
                f"Large n_results value ({n_results}) may impact performance"
            )

        result.sanitized_data = n_results
        logger.debug(f"âœ… Validated n_results: {n_results}")
        return result


class ValidationOrchestrator:
    """Orchestrates validation across multiple validators."""

    def __init__(self) -> None:
        """Initialize orchestrator with all validators."""
        self.collection_validator = CollectionValidator()
        self.document_validator = DocumentValidator()
        self.query_validator = QueryValidator()
        logger.debug("ðŸ—ï¸ ValidationOrchestrator initialized")

    def validate_collection_creation(
        self, name: str, metadata: Optional[Dict[str, Any]] = None
    ) -> ValidationResult:
        """Validate complete collection creation request."""
        name_result = self.collection_validator.validate_collection_name(name)
        if not name_result.is_valid:
            return name_result

        metadata_result = self.collection_validator.validate_metadata(metadata)
        if not metadata_result.is_valid:
            return metadata_result

        combined_result = ValidationResult(
            is_valid=True,
            errors=[],
            warnings=name_result.warnings + metadata_result.warnings,
            sanitized_data={
                "name": name_result.sanitized_data,
                "metadata": metadata_result.sanitized_data,
            },
        )

        logger.info(f"âœ… Collection creation validation passed for '{name}'")
        return combined_result

    def get_overall_stats(self) -> Dict[str, Union[int, float]]:
        """Get validation statistics from all validators."""
        collection_stats = self.collection_validator.get_validation_stats()
        document_stats = self.document_validator.get_validation_stats()
        query_stats = self.query_validator.get_validation_stats()

        total_validations = (
            collection_stats["total_validations"]
            + document_stats["total_validations"]
            + query_stats["total_validations"]
        )
        total_errors = (
            collection_stats["total_errors"]
            + document_stats["total_errors"]
            + query_stats["total_errors"]
        )

        return {
            "total_validations": total_validations,
            "total_errors": total_errors,
            "overall_success_rate": (total_validations - total_errors)
            / max(total_validations, 1),
        }


# Global validator instance
validator = ValidationOrchestrator()

# Export main classes and functions
__all__ = [
    "ValidationResult",
    "InputValidator",
    "CollectionValidator",
    "DocumentValidator",
    "QueryValidator",
    "ValidationOrchestrator",
    "validator",
]
